{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Funcparserlib Recursive descent parsing library for Python based on functional combinators. Example ... Installation ... Description ...","title":"Home"},{"location":"#funcparserlib","text":"Recursive descent parsing library for Python based on functional combinators.","title":"Funcparserlib"},{"location":"#example","text":"...","title":"Example"},{"location":"#installation","text":"...","title":"Installation"},{"location":"#description","text":"...","title":"Description"},{"location":"changes/","text":"The Changelog 1.0.0 (to be released) The stable 1.0.0 release freezes the API of funcparserlib 0.3.6 which was released on 2013-05-02. Added Added support for Python 3.10 Added support for Python 3.9 ( #63 ) (Thanks to @pkulev ) Added support for Python 3.8 Added -p (the same as skip(p) ) with more strict type hints for -p and p1 + p2 Added tok(type[, value]) for more compact grammars, better error messages Added type hints for the public API Changed Parse exceptions now show expected tokens and grammar rules at the stopped position ( #52 ) Dropped support for Python 3.4, 3.5, 3.6 (end of life) Dropped support for Python 2.5, 2.6, 3.3 (end of life), modernized code for Python 3 to run without obsolete 2to3 ( #57 ) (Thanks to @jdufresne ) Removed documentation and unit tests from the distribution Switched from setuptools to Poetry Run unit tests on GitHub Actions for all supported Pythons Fixed Fixed TypeError in oneplus when applying it parser + parser ( #66 ) (Thanks to @martica ) Fixed AttributeError when comparing Token objects to None ( #58 ) (Thanks to @Halolegend94 ) Fixed doctests in the tutorial ( #49 ) 0.3.6 \u2014 2013-05-02 Changed Python 3 compatibility More info available in exception objects ( #14 ) Fixed Fixed many() that consumed too many tokens in some cases ( #31 ) 0.3.5 \u2014 2011-01-13 Changed Python 2.4 compatibility More readable terminal names for error reporting Fixed Fixed wrong token positions in lexer error messages 0.3.4 \u2014 2009-10-06 Changed Switched from setuptools to distutils Improved the run-tests utility Fixed Fixed importing all symbols from funcparserlib.lexer 0.3.3 \u2014 2009-08-03 Added Added a FAQ question about infinite loops in parsers Changed Debug rule tracing can be enabled again Fixed Fixed a bug in results of skip + skip parsers 0.3.2 \u2014 2009-07-26 Added Added the Parsing Stages Illustrated page Fixed Fixed some string and number encoding issues in examples 0.3.1 \u2014 2009-07-26 Major optimizations (10x faster than the version 0.3). Added Added the forward_decl function, that performs better than with_forward_decls Added the pretty_tree function for creating pseudo-graphic trees Added the Nested Brackets Mini-HOWTO Added Makefile and this CHANGES.md file Changed Use a single immutable input sequence in parsers Call a wrapped parser directly using run (without __call__ ) The slow logging is enabled only when the debug flag is set 0.3 \u2014 2009-07-23 Added Added pure and bind functions on Parser s making them monads Added the Funcparserlib Tutorial Added a JSON parser as an example Changed Translated the docs from Russian into English 0.2 \u2014 2009-07-07 Added Added the with_forward_decls combinator for dealing with forward declarations Changed Switched to the iterative implementation of many Un-curried the parser function type in order to simplify things Improvements to the DOT parser 0.1 \u2014 2009-06-26 Initial release.","title":"Changelog"},{"location":"changes/#the-changelog","text":"","title":"The Changelog"},{"location":"changes/#100-to-be-released","text":"The stable 1.0.0 release freezes the API of funcparserlib 0.3.6 which was released on 2013-05-02.","title":"1.0.0 (to be released)"},{"location":"changes/#added","text":"Added support for Python 3.10 Added support for Python 3.9 ( #63 ) (Thanks to @pkulev ) Added support for Python 3.8 Added -p (the same as skip(p) ) with more strict type hints for -p and p1 + p2 Added tok(type[, value]) for more compact grammars, better error messages Added type hints for the public API","title":"Added"},{"location":"changes/#changed","text":"Parse exceptions now show expected tokens and grammar rules at the stopped position ( #52 ) Dropped support for Python 3.4, 3.5, 3.6 (end of life) Dropped support for Python 2.5, 2.6, 3.3 (end of life), modernized code for Python 3 to run without obsolete 2to3 ( #57 ) (Thanks to @jdufresne ) Removed documentation and unit tests from the distribution Switched from setuptools to Poetry Run unit tests on GitHub Actions for all supported Pythons","title":"Changed"},{"location":"changes/#fixed","text":"Fixed TypeError in oneplus when applying it parser + parser ( #66 ) (Thanks to @martica ) Fixed AttributeError when comparing Token objects to None ( #58 ) (Thanks to @Halolegend94 ) Fixed doctests in the tutorial ( #49 )","title":"Fixed"},{"location":"changes/#036-2013-05-02","text":"","title":"0.3.6 \u2014 2013-05-02"},{"location":"changes/#changed_1","text":"Python 3 compatibility More info available in exception objects ( #14 )","title":"Changed"},{"location":"changes/#fixed_1","text":"Fixed many() that consumed too many tokens in some cases ( #31 )","title":"Fixed"},{"location":"changes/#035-2011-01-13","text":"","title":"0.3.5 \u2014 2011-01-13"},{"location":"changes/#changed_2","text":"Python 2.4 compatibility More readable terminal names for error reporting","title":"Changed"},{"location":"changes/#fixed_2","text":"Fixed wrong token positions in lexer error messages","title":"Fixed"},{"location":"changes/#034-2009-10-06","text":"","title":"0.3.4 \u2014 2009-10-06"},{"location":"changes/#changed_3","text":"Switched from setuptools to distutils Improved the run-tests utility","title":"Changed"},{"location":"changes/#fixed_3","text":"Fixed importing all symbols from funcparserlib.lexer","title":"Fixed"},{"location":"changes/#033-2009-08-03","text":"","title":"0.3.3 \u2014 2009-08-03"},{"location":"changes/#added_1","text":"Added a FAQ question about infinite loops in parsers","title":"Added"},{"location":"changes/#changed_4","text":"Debug rule tracing can be enabled again","title":"Changed"},{"location":"changes/#fixed_4","text":"Fixed a bug in results of skip + skip parsers","title":"Fixed"},{"location":"changes/#032-2009-07-26","text":"","title":"0.3.2 \u2014 2009-07-26"},{"location":"changes/#added_2","text":"Added the Parsing Stages Illustrated page","title":"Added"},{"location":"changes/#fixed_5","text":"Fixed some string and number encoding issues in examples","title":"Fixed"},{"location":"changes/#031-2009-07-26","text":"Major optimizations (10x faster than the version 0.3).","title":"0.3.1 \u2014 2009-07-26"},{"location":"changes/#added_3","text":"Added the forward_decl function, that performs better than with_forward_decls Added the pretty_tree function for creating pseudo-graphic trees Added the Nested Brackets Mini-HOWTO Added Makefile and this CHANGES.md file","title":"Added"},{"location":"changes/#changed_5","text":"Use a single immutable input sequence in parsers Call a wrapped parser directly using run (without __call__ ) The slow logging is enabled only when the debug flag is set","title":"Changed"},{"location":"changes/#03-2009-07-23","text":"","title":"0.3 \u2014 2009-07-23"},{"location":"changes/#added_4","text":"Added pure and bind functions on Parser s making them monads Added the Funcparserlib Tutorial Added a JSON parser as an example","title":"Added"},{"location":"changes/#changed_6","text":"Translated the docs from Russian into English","title":"Changed"},{"location":"changes/#02-2009-07-07","text":"","title":"0.2 \u2014 2009-07-07"},{"location":"changes/#added_5","text":"Added the with_forward_decls combinator for dealing with forward declarations","title":"Added"},{"location":"changes/#changed_7","text":"Switched to the iterative implementation of many Un-curried the parser function type in order to simplify things Improvements to the DOT parser","title":"Changed"},{"location":"changes/#01-2009-06-26","text":"Initial release.","title":"0.1 \u2014 2009-06-26"},{"location":"api/","text":"API Reference Funcparserlib consists of the following modules: funcparserlib.parser \u2014 Functional parsing combinators funcparserlib.lexer \u2014 Regexp-based tokenizer funcparserlib.util \u2014 Various utilities","title":"API Overview"},{"location":"api/#api-reference","text":"Funcparserlib consists of the following modules: funcparserlib.parser \u2014 Functional parsing combinators funcparserlib.lexer \u2014 Regexp-based tokenizer funcparserlib.util \u2014 Various utilities","title":"API Reference"},{"location":"api/lexer/","text":"funcparserlib.lexer \u2014 Regexp-based tokenizer funcparserlib . lexer . make_tokenizer ( specs ) Make a function that tokenizes text based on the regexp specs. Type: (Sequence[Tuple[str, Tuple[Any, ...]]]) -> Callable[[str], Iterable[Token]] A token spec is a tuple of ( type , args ), where type sets the value of Token.type for a found token, and args are the positional arguments for re.compile() : either just ( pattern ,) or ( pattern , flags ). It returns a tokenizer function that takes a string and returns an iterable of Token objects, or raises LexerError if it cannot tokenize the string according to its token specs. Examples: >>> tokenize = make_tokenizer ([ ... ( \"space\" , ( r \"\\s+\" ,)), ... ( \"id\" , ( r \"\\w+\" ,)), ... ( \"op\" , ( r \"[,!]\" ,)), ... ]) >>> text = \"Hello, World!\" >>> [ t for t in tokenize ( text ) if t . type != \"space\" ] # noqa [Token('id', 'Hello'), Token('op', ','), Token('id', 'World'), Token('op', '!')] >>> text = \"Bye?\" >>> list ( tokenize ( text )) Traceback (most recent call last): ... lexer.LexerError : cannot tokenize data: 1,4: \"Bye?\" funcparserlib.lexer.Token Bases: object A token object that represents a substring of certain type in your text. You can compare tokens for equality using the == operator. Tokens also define custom repr() and str() . Attributes: Name Type Description type str User-defined type of the token (e.g. \"name\" , \"number\" , \"operator\" ) value str Text value of the token start Optional [ Tuple [ int , int ]] Start position ( line , column ) end Optional [ Tuple [ int , int ]] End position ( line , column ) __init__ ( type , value , start = None , end = None ) Initialize a Token object. funcparserlib . lexer . Token . __init__ ( type , value , start = None , end = None ) Initialize a Token object.","title":"Lexer"},{"location":"api/lexer/#funcparserliblexer-regexp-based-tokenizer","text":"","title":"funcparserlib.lexer \u2014 Regexp-based tokenizer"},{"location":"api/lexer/#funcparserlib.lexer.make_tokenizer","text":"Make a function that tokenizes text based on the regexp specs. Type: (Sequence[Tuple[str, Tuple[Any, ...]]]) -> Callable[[str], Iterable[Token]] A token spec is a tuple of ( type , args ), where type sets the value of Token.type for a found token, and args are the positional arguments for re.compile() : either just ( pattern ,) or ( pattern , flags ). It returns a tokenizer function that takes a string and returns an iterable of Token objects, or raises LexerError if it cannot tokenize the string according to its token specs. Examples: >>> tokenize = make_tokenizer ([ ... ( \"space\" , ( r \"\\s+\" ,)), ... ( \"id\" , ( r \"\\w+\" ,)), ... ( \"op\" , ( r \"[,!]\" ,)), ... ]) >>> text = \"Hello, World!\" >>> [ t for t in tokenize ( text ) if t . type != \"space\" ] # noqa [Token('id', 'Hello'), Token('op', ','), Token('id', 'World'), Token('op', '!')] >>> text = \"Bye?\" >>> list ( tokenize ( text )) Traceback (most recent call last): ... lexer.LexerError : cannot tokenize data: 1,4: \"Bye?\"","title":"make_tokenizer()"},{"location":"api/lexer/#funcparserlib.lexer.Token","text":"Bases: object A token object that represents a substring of certain type in your text. You can compare tokens for equality using the == operator. Tokens also define custom repr() and str() . Attributes: Name Type Description type str User-defined type of the token (e.g. \"name\" , \"number\" , \"operator\" ) value str Text value of the token start Optional [ Tuple [ int , int ]] Start position ( line , column ) end Optional [ Tuple [ int , int ]] End position ( line , column )","title":"Token"},{"location":"api/lexer/#funcparserlib.lexer.Token.__init__","text":"Initialize a Token object.","title":"__init__()"},{"location":"api/lexer/#funcparserlib.lexer.Token.__init__","text":"Initialize a Token object.","title":"__init__()"},{"location":"api/parser/","text":"funcparserlib.parser \u2014 Functional parsing combinators Functional parsing combinators. Parsing combinators define an internal domain-specific language (DSL) for describing the parsing rules of a grammar. The DSL allows you to start with a few primitive parsers, then combine your parsers to get more complex ones, and finally cover the whole grammar you want to parse. The structure of the language: Class Parser All the primitives and combinators of the language return Parser objects It defines the main Parser.parse(tokens) method Primitive parsers tok(type, value) , a(value) , some(pred) , forward_decl() , finished Parser combinators p1 + p2 , p1 | p2 , p >> f , -p , maybe(p) , many(p) , oneplus(p) , skip(p) Abstraction Use regular Python variables p = ... # Expression of type Parser to define new rules (non-terminals) of your grammar Every time you apply one of the combinators, you get a new Parser object. In other words, the set of Parser objects is closed under the means of combination. Note We took the parsing combinators language from the book Introduction to Functional Programming and translated it from ML into Python. Parser Bases: object A parser object that can parse a sequence of tokens or can be combined with other parsers using + , | , >> , many() , and other parsing combinators. Type: Parser[A, B] The generic variables in the type are: A \u2014 the type of the tokens in the sequence to parse, B \u2014 the type of the parsed value. In order to define a parser for your grammar: You start with primitive parsers by calling a(value) , some(pred) , forward_decl() , finished You use parsing combinators p1 + p2 , p1 | p2 , p >> f , many(p) , and others to combine parsers into a more complex parser You can assign complex parsers to variables to define names that correspond to the rules of your grammar Note The constructor Parser.__init__() is considered internal and may be changed in future versions. Use primitive parsers and parsing combinators to construct new parsers. __add__ ( other ) Sequential combination of parsers. It runs this parser, then the other parser. The return value of the resulting parser is a tuple of each parsed value in the sum of parsers. We merge all parsing results of p1 + p2 + ... + pN into a single tuple. It means that the parsing result may be a 2-tuple, a 3-tuple, a 4-tuple, etc. of parsed values. You avoid this by transforming the parsed pair into a new value using the >> combinator. You can also skip some parsing results in the resulting parsers by using -p or skip(p) for some parsers in your sum of parsers. It means that the parsing result might be a single value, not a tuple of parsed values. See the docs for Parser.__neg__() for more examples. Overloaded types (lots of them to provide stricter checking for the quite dynamic return type of this method): (self: Parser[A, B], _IgnoredParser[A]) -> Parser[A, B] (self: Parser[A, B], Parser[A, C]) -> _TupleParser[A, Tuple[B, C]] (self: _TupleParser[A, B], _IgnoredParser[A]) -> _TupleParser[A, B] (self: _TupleParser[A, B], Parser[A, Any]) -> Parser[A, Any] (self: _IgnoredParser[A], _IgnoredParser[A]) -> _IgnoredParser[A] (self: _IgnoredParser[A], Parser[A, C]) -> Parser[A, C] Examples: >>> expr = a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"xy\" ) ('x', 'y') >>> expr = a ( \"x\" ) + a ( \"y\" ) + a ( \"z\" ) >>> expr . parse ( \"xyz\" ) ('x', 'y', 'z') >>> expr = a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"xz\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'z', expected: 'y' __init__ ( p ) Wrap the parser function p into a Parser object. __neg__ () Return a parser that parses the same tokens, but its parsing result is ignored by the sequential + combinator. Type: (Parser[A, B]) -> _IgnoredParser[A] You can use it for throwing away elements of concrete syntax (e.g. \",\" , \";\" ). Examples: >>> expr = - a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"xy\" ) 'y' >>> expr = a ( \"x\" ) + - a ( \"y\" ) >>> expr . parse ( \"xy\" ) 'x' >>> expr = a ( \"x\" ) + - a ( \"y\" ) + a ( \"z\" ) >>> expr . parse ( \"xyz\" ) ('x', 'z') >>> expr = - a ( \"x\" ) + a ( \"y\" ) + - a ( \"z\" ) >>> expr . parse ( \"xyz\" ) 'y' >>> expr = - a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"yz\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'y', expected: 'x' >>> expr = a ( \"x\" ) + - a ( \"y\" ) >>> expr . parse ( \"xz\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'z', expected: 'y' Note You should not pass the resulting parser to any combinators other than + . You should have at least one non-skipped value in your p1 + p2 + ... + pN . The parsed value of -p is an internal _Ignored object, not intended for actual use. __or__ ( other ) Choice combination of parsers. It runs this parser and returns its result. If the parser fails, it runs the other parser. Examples: >>> expr = a ( \"x\" ) | a ( \"y\" ) >>> expr . parse ( \"x\" ) 'x' >>> expr . parse ( \"y\" ) 'y' >>> expr . parse ( \"z\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'z', expected: 'x' or 'y' __rshift__ ( f ) Transform the parsing result by applying the specified function. Type: (Callable[[B], C]) -> Parser[A, C] You can use it for transforming the parsed value into another value before including it into the parse tree (the AST). Examples: >>> def make_canonical_name ( s ): ... return s . lower () >>> expr = ( a ( \"D\" ) | a ( \"d\" )) >> make_canonical_name >>> expr . parse ( \"D\" ) 'd' >>> expr . parse ( \"d\" ) 'd' bind ( f ) Bind the parser to a monadic function that returns a new parser. Type: (Callable[[B], Parser[A, C]]) -> Parser[A, C] Also known as >>= in Haskell. Note You can parse any context-free grammar without resorting to bind . Due to its poor performance please use it only when you really need it. define ( p ) Define the parser created earlier as a forward declaration. Type: (Parser[A, B]) -> None Use p = forward_decl() in combination with p.define(...) to define recursive parsers. See the examples in the docs for forward_decl() . named ( name ) Specify the name of the parser for easier debugging. Type: (str) -> Parser[A, B] This name is used in the debug-level parsing log. You can also get it via the Parser.name attribute. Examples: >>> expr = ( a ( \"x\" ) + a ( \"y\" )) . named ( \"expr\" ) >>> expr . name 'expr' >>> expr = a ( \"x\" ) + a ( \"y\" ) >>> expr . name \"('x', 'y')\" Note You can enable the parsing log this way: import logging logging . basicConfig ( level = logging . DEBUG ) import funcparserlib.parser funcparserlib . parser . debug = True The way to enable the parsing log may be changed in future versions. parse ( tokens ) Parse the sequence of tokens and return the parsed value. Type: (Sequence[A]) -> B It takes a sequence of tokens of arbitrary type A and returns the parsed value of arbitrary type B . If the parser fails to parse the tokens, it raises NoParseError . Note Although Parser.parse() can parse sequences of any objects (including str which is a sequence of str chars), the recommended way is parsing sequences of Token objects. You should use a regexp-based tokenizer make_tokenizer() defined in funcparserlib.lexer to convert your text into a sequence of Token objects before parsing it. You will get more readable parsing error messages (as Token objects contain their position in the source file) and good separation of the lexical and syntactic levels of the grammar. run ( tokens , s ) Run the parser against the tokens with the specified parsing state. Type: (Sequence[A], State) -> Tuple[B, State] The parsing state includes the current position in the sequence being parsed, and the position of the rightmost token that has been consumed while parsing for better error messages. If the parser fails to parse the tokens, it raises NoParseError . Warning This is method is internal and may be changed in future versions. Use Parser.parse(tokens) instead and let the parser object take care of updating the parsing state. State Bases: object Parsing state that is maintained basically for error reporting. It consists of the current position pos in the sequence being parsed, and the position max of the rightmost token that has been consumed while parsing. a ( value ) Return a parser that parses a token if it's equal to value . Type: (A) -> Parser[A, A] Examples: >>> expr = a ( \"x\" ) >>> expr . parse ( \"x\" ) 'x' >>> expr . parse ( \"y\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'y', expected: 'x' Note Although Parser.parse() can parse sequences of any objects (including str which is a sequence of str chars), the recommended way is parsing sequences of Token objects. You should use a regexp-based tokenizer make_tokenizer() defined in funcparserlib.lexer to convert your text into a sequence of Token objects before parsing it. You will get more readable parsing error messages (as Token objects contain their position in the source file) and good separation of the lexical and syntactic levels of the grammar. finished ( tokens , s ) A parser that throws an exception if there are any unparsed tokens left in the sequence. forward_decl () Return an undefined parser that can be used as a forward declaration. Type: Parser[Any, Any] Use p = forward_decl() in combination with p.define(...) to define recursive parsers. Examples: >>> expr = forward_decl () >>> expr . define ( a ( \"x\" ) + maybe ( expr ) + a ( \"y\" )) >>> expr . parse ( \"xxyy\" ) # noqa ('x', ('x', None, 'y'), 'y') >>> expr . parse ( \"xxy\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected end of file, expected: 'y' Note If you care about static types, you should add a type hint for your forward declaration, so that your type checker can check types in p.define(...) later: p : Parser [ str , int ] = forward_decl () p . define ( a ( \"x\" )) # Type checker error p . define ( a ( \"1\" ) >> int ) # OK many ( p ) Return a parser that applies the parser p as many times as it succeeds at parsing the tokens. Return a parser that infinitely applies the parser p to the input sequence of tokens as long as it successfully parses them. The parsed value is a list of the sequentially parsed values. Examples: >>> expr = many ( a ( \"x\" )) >>> expr . parse ( \"x\" ) ['x'] >>> expr . parse ( \"xx\" ) ['x', 'x'] >>> expr . parse ( \"xxxy\" ) # noqa ['x', 'x', 'x'] >>> expr . parse ( \"y\" ) [] maybe ( p ) Return a parser that returns None if the parser p fails. Examples: >>> expr = maybe ( a ( \"x\" )) >>> expr . parse ( \"x\" ) 'x' >>> expr . parse ( \"y\" ) is None True oneplus ( p ) Return a parser that applies the parser p one or more times. A similar parser combinator many(p) means apply p zero or more times, whereas oneplus(p) means apply p one or more times. Examples: >>> expr = oneplus ( a ( \"x\" )) >>> expr . parse ( \"x\" ) ['x'] >>> expr . parse ( \"xx\" ) ['x', 'x'] >>> expr . parse ( \"y\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'y', expected: 'x' pure ( x ) Wrap any object into a parser. Type: (A) -> Parser[A, A] A pure parser doesn't touch the tokens sequence, it just returns its pure x value. Also known as return in Haskell. skip ( p ) An alias for -p . See also the docs for Parser.__neg__() . some ( pred ) Return a parser that parses a token if it satisfies the predicate pred . Type: (Callable[[A], bool]) -> Parser[A, A] Examples: >>> expr = some ( lambda s : s . isalpha ()) . named ( 'alpha' ) >>> expr . parse ( \"x\" ) 'x' >>> expr . parse ( \"y\" ) 'y' >>> expr . parse ( \"1\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: '1', expected: alpha Warning The some() combinator is quite slow and may be changed or removed in future versions. If you need a parser for a token by its type (e.g. any identifier) and maybe its value, use tok(type[, value]) instead. You should use make_tokenizer() from funcparserlib.lexer to tokenize your text first. tok ( type , value = None ) Return a parser that parses a Token and returns the string value of the token. Type: (str, Optional[str]) -> Parser[Token, str] You can match any token of the specified type or you can match a specific token by its type and value . Examples: >>> expr = tok ( \"expr\" ) >>> expr . parse ([ Token ( \"expr\" , \"foo\" )]) 'foo' >>> expr . parse ([ Token ( \"expr\" , \"bar\" )]) 'bar' >>> expr . parse ([ Token ( \"op\" , \"=\" )]) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: '=', expected: expr >>> expr = tok ( \"op\" , \"=\" ) >>> expr . parse ([ Token ( \"op\" , \"=\" )]) '=' >>> expr . parse ([ Token ( \"op\" , \"+\" )]) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: '+', expected: '=' Note In order to convert your text to parse into a sequence of Token objects, use a regexp-based tokenizer make_tokenizer() defined in funcparserlib.lexer . You will get more readable parsing error messages (as Token objects contain their position in the source file) and good separation of the lexical and syntactic levels of the grammar. funcparserlib.parser.Parser Bases: object A parser object that can parse a sequence of tokens or can be combined with other parsers using + , | , >> , many() , and other parsing combinators. Type: Parser[A, B] The generic variables in the type are: A \u2014 the type of the tokens in the sequence to parse, B \u2014 the type of the parsed value. In order to define a parser for your grammar: You start with primitive parsers by calling a(value) , some(pred) , forward_decl() , finished You use parsing combinators p1 + p2 , p1 | p2 , p >> f , many(p) , and others to combine parsers into a more complex parser You can assign complex parsers to variables to define names that correspond to the rules of your grammar Note The constructor Parser.__init__() is considered internal and may be changed in future versions. Use primitive parsers and parsing combinators to construct new parsers. __add__ ( other ) Sequential combination of parsers. It runs this parser, then the other parser. The return value of the resulting parser is a tuple of each parsed value in the sum of parsers. We merge all parsing results of p1 + p2 + ... + pN into a single tuple. It means that the parsing result may be a 2-tuple, a 3-tuple, a 4-tuple, etc. of parsed values. You avoid this by transforming the parsed pair into a new value using the >> combinator. You can also skip some parsing results in the resulting parsers by using -p or skip(p) for some parsers in your sum of parsers. It means that the parsing result might be a single value, not a tuple of parsed values. See the docs for Parser.__neg__() for more examples. Overloaded types (lots of them to provide stricter checking for the quite dynamic return type of this method): (self: Parser[A, B], _IgnoredParser[A]) -> Parser[A, B] (self: Parser[A, B], Parser[A, C]) -> _TupleParser[A, Tuple[B, C]] (self: _TupleParser[A, B], _IgnoredParser[A]) -> _TupleParser[A, B] (self: _TupleParser[A, B], Parser[A, Any]) -> Parser[A, Any] (self: _IgnoredParser[A], _IgnoredParser[A]) -> _IgnoredParser[A] (self: _IgnoredParser[A], Parser[A, C]) -> Parser[A, C] Examples: >>> expr = a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"xy\" ) ('x', 'y') >>> expr = a ( \"x\" ) + a ( \"y\" ) + a ( \"z\" ) >>> expr . parse ( \"xyz\" ) ('x', 'y', 'z') >>> expr = a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"xz\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'z', expected: 'y' __init__ ( p ) Wrap the parser function p into a Parser object. __neg__ () Return a parser that parses the same tokens, but its parsing result is ignored by the sequential + combinator. Type: (Parser[A, B]) -> _IgnoredParser[A] You can use it for throwing away elements of concrete syntax (e.g. \",\" , \";\" ). Examples: >>> expr = - a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"xy\" ) 'y' >>> expr = a ( \"x\" ) + - a ( \"y\" ) >>> expr . parse ( \"xy\" ) 'x' >>> expr = a ( \"x\" ) + - a ( \"y\" ) + a ( \"z\" ) >>> expr . parse ( \"xyz\" ) ('x', 'z') >>> expr = - a ( \"x\" ) + a ( \"y\" ) + - a ( \"z\" ) >>> expr . parse ( \"xyz\" ) 'y' >>> expr = - a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"yz\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'y', expected: 'x' >>> expr = a ( \"x\" ) + - a ( \"y\" ) >>> expr . parse ( \"xz\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'z', expected: 'y' Note You should not pass the resulting parser to any combinators other than + . You should have at least one non-skipped value in your p1 + p2 + ... + pN . The parsed value of -p is an internal _Ignored object, not intended for actual use. __or__ ( other ) Choice combination of parsers. It runs this parser and returns its result. If the parser fails, it runs the other parser. Examples: >>> expr = a ( \"x\" ) | a ( \"y\" ) >>> expr . parse ( \"x\" ) 'x' >>> expr . parse ( \"y\" ) 'y' >>> expr . parse ( \"z\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'z', expected: 'x' or 'y' __rshift__ ( f ) Transform the parsing result by applying the specified function. Type: (Callable[[B], C]) -> Parser[A, C] You can use it for transforming the parsed value into another value before including it into the parse tree (the AST). Examples: >>> def make_canonical_name ( s ): ... return s . lower () >>> expr = ( a ( \"D\" ) | a ( \"d\" )) >> make_canonical_name >>> expr . parse ( \"D\" ) 'd' >>> expr . parse ( \"d\" ) 'd' bind ( f ) Bind the parser to a monadic function that returns a new parser. Type: (Callable[[B], Parser[A, C]]) -> Parser[A, C] Also known as >>= in Haskell. Note You can parse any context-free grammar without resorting to bind . Due to its poor performance please use it only when you really need it. define ( p ) Define the parser created earlier as a forward declaration. Type: (Parser[A, B]) -> None Use p = forward_decl() in combination with p.define(...) to define recursive parsers. See the examples in the docs for forward_decl() . named ( name ) Specify the name of the parser for easier debugging. Type: (str) -> Parser[A, B] This name is used in the debug-level parsing log. You can also get it via the Parser.name attribute. Examples: >>> expr = ( a ( \"x\" ) + a ( \"y\" )) . named ( \"expr\" ) >>> expr . name 'expr' >>> expr = a ( \"x\" ) + a ( \"y\" ) >>> expr . name \"('x', 'y')\" Note You can enable the parsing log this way: import logging logging . basicConfig ( level = logging . DEBUG ) import funcparserlib.parser funcparserlib . parser . debug = True The way to enable the parsing log may be changed in future versions. parse ( tokens ) Parse the sequence of tokens and return the parsed value. Type: (Sequence[A]) -> B It takes a sequence of tokens of arbitrary type A and returns the parsed value of arbitrary type B . If the parser fails to parse the tokens, it raises NoParseError . Note Although Parser.parse() can parse sequences of any objects (including str which is a sequence of str chars), the recommended way is parsing sequences of Token objects. You should use a regexp-based tokenizer make_tokenizer() defined in funcparserlib.lexer to convert your text into a sequence of Token objects before parsing it. You will get more readable parsing error messages (as Token objects contain their position in the source file) and good separation of the lexical and syntactic levels of the grammar. run ( tokens , s ) Run the parser against the tokens with the specified parsing state. Type: (Sequence[A], State) -> Tuple[B, State] The parsing state includes the current position in the sequence being parsed, and the position of the rightmost token that has been consumed while parsing for better error messages. If the parser fails to parse the tokens, it raises NoParseError . Warning This is method is internal and may be changed in future versions. Use Parser.parse(tokens) instead and let the parser object take care of updating the parsing state. funcparserlib . parser . Parser . parse ( tokens ) Parse the sequence of tokens and return the parsed value. Type: (Sequence[A]) -> B It takes a sequence of tokens of arbitrary type A and returns the parsed value of arbitrary type B . If the parser fails to parse the tokens, it raises NoParseError . Note Although Parser.parse() can parse sequences of any objects (including str which is a sequence of str chars), the recommended way is parsing sequences of Token objects. You should use a regexp-based tokenizer make_tokenizer() defined in funcparserlib.lexer to convert your text into a sequence of Token objects before parsing it. You will get more readable parsing error messages (as Token objects contain their position in the source file) and good separation of the lexical and syntactic levels of the grammar. funcparserlib . parser . Parser . define ( p ) Define the parser created earlier as a forward declaration. Type: (Parser[A, B]) -> None Use p = forward_decl() in combination with p.define(...) to define recursive parsers. See the examples in the docs for forward_decl() . funcparserlib . parser . Parser . named ( name ) Specify the name of the parser for easier debugging. Type: (str) -> Parser[A, B] This name is used in the debug-level parsing log. You can also get it via the Parser.name attribute. Examples: >>> expr = ( a ( \"x\" ) + a ( \"y\" )) . named ( \"expr\" ) >>> expr . name 'expr' >>> expr = a ( \"x\" ) + a ( \"y\" ) >>> expr . name \"('x', 'y')\" Note You can enable the parsing log this way: import logging logging . basicConfig ( level = logging . DEBUG ) import funcparserlib.parser funcparserlib . parser . debug = True The way to enable the parsing log may be changed in future versions. Primitive Parsers funcparserlib . parser . tok ( type , value = None ) Return a parser that parses a Token and returns the string value of the token. Type: (str, Optional[str]) -> Parser[Token, str] You can match any token of the specified type or you can match a specific token by its type and value . Examples: >>> expr = tok ( \"expr\" ) >>> expr . parse ([ Token ( \"expr\" , \"foo\" )]) 'foo' >>> expr . parse ([ Token ( \"expr\" , \"bar\" )]) 'bar' >>> expr . parse ([ Token ( \"op\" , \"=\" )]) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: '=', expected: expr >>> expr = tok ( \"op\" , \"=\" ) >>> expr . parse ([ Token ( \"op\" , \"=\" )]) '=' >>> expr . parse ([ Token ( \"op\" , \"+\" )]) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: '+', expected: '=' Note In order to convert your text to parse into a sequence of Token objects, use a regexp-based tokenizer make_tokenizer() defined in funcparserlib.lexer . You will get more readable parsing error messages (as Token objects contain their position in the source file) and good separation of the lexical and syntactic levels of the grammar. funcparserlib . parser . a ( value ) Return a parser that parses a token if it's equal to value . Type: (A) -> Parser[A, A] Examples: >>> expr = a ( \"x\" ) >>> expr . parse ( \"x\" ) 'x' >>> expr . parse ( \"y\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'y', expected: 'x' Note Although Parser.parse() can parse sequences of any objects (including str which is a sequence of str chars), the recommended way is parsing sequences of Token objects. You should use a regexp-based tokenizer make_tokenizer() defined in funcparserlib.lexer to convert your text into a sequence of Token objects before parsing it. You will get more readable parsing error messages (as Token objects contain their position in the source file) and good separation of the lexical and syntactic levels of the grammar. funcparserlib . parser . some ( pred ) Return a parser that parses a token if it satisfies the predicate pred . Type: (Callable[[A], bool]) -> Parser[A, A] Examples: >>> expr = some ( lambda s : s . isalpha ()) . named ( 'alpha' ) >>> expr . parse ( \"x\" ) 'x' >>> expr . parse ( \"y\" ) 'y' >>> expr . parse ( \"1\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: '1', expected: alpha Warning The some() combinator is quite slow and may be changed or removed in future versions. If you need a parser for a token by its type (e.g. any identifier) and maybe its value, use tok(type[, value]) instead. You should use make_tokenizer() from funcparserlib.lexer to tokenize your text first. funcparserlib . parser . forward_decl () Return an undefined parser that can be used as a forward declaration. Type: Parser[Any, Any] Use p = forward_decl() in combination with p.define(...) to define recursive parsers. Examples: >>> expr = forward_decl () >>> expr . define ( a ( \"x\" ) + maybe ( expr ) + a ( \"y\" )) >>> expr . parse ( \"xxyy\" ) # noqa ('x', ('x', None, 'y'), 'y') >>> expr . parse ( \"xxy\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected end of file, expected: 'y' Note If you care about static types, you should add a type hint for your forward declaration, so that your type checker can check types in p.define(...) later: p : Parser [ str , int ] = forward_decl () p . define ( a ( \"x\" )) # Type checker error p . define ( a ( \"1\" ) >> int ) # OK finished A parser that throws an exception if there are any unparsed tokens left in the sequence. Type: Parser[Any, None] Examples: >>> from funcparserlib.parser import a , finished >>> expr = a ( \"x\" ) + finished >>> expr . parse ( \"x\" ) ('x', None) >>> expr = a ( \"x\" ) + finished >>> expr . parse ( \"xy\" ) Traceback (most recent call last): ... funcparserlib.parser.NoParseError : got unexpected token: 'y', expected: end of file Parser Combinators funcparserlib . parser . Parser . __add__ ( other ) Sequential combination of parsers. It runs this parser, then the other parser. The return value of the resulting parser is a tuple of each parsed value in the sum of parsers. We merge all parsing results of p1 + p2 + ... + pN into a single tuple. It means that the parsing result may be a 2-tuple, a 3-tuple, a 4-tuple, etc. of parsed values. You avoid this by transforming the parsed pair into a new value using the >> combinator. You can also skip some parsing results in the resulting parsers by using -p or skip(p) for some parsers in your sum of parsers. It means that the parsing result might be a single value, not a tuple of parsed values. See the docs for Parser.__neg__() for more examples. Overloaded types (lots of them to provide stricter checking for the quite dynamic return type of this method): (self: Parser[A, B], _IgnoredParser[A]) -> Parser[A, B] (self: Parser[A, B], Parser[A, C]) -> _TupleParser[A, Tuple[B, C]] (self: _TupleParser[A, B], _IgnoredParser[A]) -> _TupleParser[A, B] (self: _TupleParser[A, B], Parser[A, Any]) -> Parser[A, Any] (self: _IgnoredParser[A], _IgnoredParser[A]) -> _IgnoredParser[A] (self: _IgnoredParser[A], Parser[A, C]) -> Parser[A, C] Examples: >>> expr = a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"xy\" ) ('x', 'y') >>> expr = a ( \"x\" ) + a ( \"y\" ) + a ( \"z\" ) >>> expr . parse ( \"xyz\" ) ('x', 'y', 'z') >>> expr = a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"xz\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'z', expected: 'y' funcparserlib . parser . Parser . __neg__ () Return a parser that parses the same tokens, but its parsing result is ignored by the sequential + combinator. Type: (Parser[A, B]) -> _IgnoredParser[A] You can use it for throwing away elements of concrete syntax (e.g. \",\" , \";\" ). Examples: >>> expr = - a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"xy\" ) 'y' >>> expr = a ( \"x\" ) + - a ( \"y\" ) >>> expr . parse ( \"xy\" ) 'x' >>> expr = a ( \"x\" ) + - a ( \"y\" ) + a ( \"z\" ) >>> expr . parse ( \"xyz\" ) ('x', 'z') >>> expr = - a ( \"x\" ) + a ( \"y\" ) + - a ( \"z\" ) >>> expr . parse ( \"xyz\" ) 'y' >>> expr = - a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"yz\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'y', expected: 'x' >>> expr = a ( \"x\" ) + - a ( \"y\" ) >>> expr . parse ( \"xz\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'z', expected: 'y' Note You should not pass the resulting parser to any combinators other than + . You should have at least one non-skipped value in your p1 + p2 + ... + pN . The parsed value of -p is an internal _Ignored object, not intended for actual use. funcparserlib . parser . Parser . __or__ ( other ) Choice combination of parsers. It runs this parser and returns its result. If the parser fails, it runs the other parser. Examples: >>> expr = a ( \"x\" ) | a ( \"y\" ) >>> expr . parse ( \"x\" ) 'x' >>> expr . parse ( \"y\" ) 'y' >>> expr . parse ( \"z\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'z', expected: 'x' or 'y' funcparserlib . parser . Parser . __rshift__ ( f ) Transform the parsing result by applying the specified function. Type: (Callable[[B], C]) -> Parser[A, C] You can use it for transforming the parsed value into another value before including it into the parse tree (the AST). Examples: >>> def make_canonical_name ( s ): ... return s . lower () >>> expr = ( a ( \"D\" ) | a ( \"d\" )) >> make_canonical_name >>> expr . parse ( \"D\" ) 'd' >>> expr . parse ( \"d\" ) 'd' funcparserlib . parser . maybe ( p ) Return a parser that returns None if the parser p fails. Examples: >>> expr = maybe ( a ( \"x\" )) >>> expr . parse ( \"x\" ) 'x' >>> expr . parse ( \"y\" ) is None True funcparserlib . parser . many ( p ) Return a parser that applies the parser p as many times as it succeeds at parsing the tokens. Return a parser that infinitely applies the parser p to the input sequence of tokens as long as it successfully parses them. The parsed value is a list of the sequentially parsed values. Examples: >>> expr = many ( a ( \"x\" )) >>> expr . parse ( \"x\" ) ['x'] >>> expr . parse ( \"xx\" ) ['x', 'x'] >>> expr . parse ( \"xxxy\" ) # noqa ['x', 'x', 'x'] >>> expr . parse ( \"y\" ) [] funcparserlib . parser . oneplus ( p ) Return a parser that applies the parser p one or more times. A similar parser combinator many(p) means apply p zero or more times, whereas oneplus(p) means apply p one or more times. Examples: >>> expr = oneplus ( a ( \"x\" )) >>> expr . parse ( \"x\" ) ['x'] >>> expr . parse ( \"xx\" ) ['x', 'x'] >>> expr . parse ( \"y\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'y', expected: 'x' funcparserlib . parser . skip ( p ) An alias for -p . See also the docs for Parser.__neg__() . Extra: Parser Monad As a functional programmer, you might be pleased to know, that parsers in funcparserlib form a monad with Parser.bind() as >>= and pure() as return . We could have expressed other parsing combinators in terms of bind() , but would be inefficient in Python: # noinspection PyUnresolvedReferences class Parser : def __add__ ( self , other ): return self . bind ( lambda x : other . bind ( lambda y : pure (( x , y )))) def __rshift__ ( self , other ): return self . bind ( lambda x : pure ( x )) funcparserlib . parser . Parser . bind ( f ) Bind the parser to a monadic function that returns a new parser. Type: (Callable[[B], Parser[A, C]]) -> Parser[A, C] Also known as >>= in Haskell. Note You can parse any context-free grammar without resorting to bind . Due to its poor performance please use it only when you really need it. funcparserlib . parser . pure ( x ) Wrap any object into a parser. Type: (A) -> Parser[A, A] A pure parser doesn't touch the tokens sequence, it just returns its pure x value. Also known as return in Haskell.","title":"Parser"},{"location":"api/parser/#funcparserlibparser-functional-parsing-combinators","text":"Functional parsing combinators. Parsing combinators define an internal domain-specific language (DSL) for describing the parsing rules of a grammar. The DSL allows you to start with a few primitive parsers, then combine your parsers to get more complex ones, and finally cover the whole grammar you want to parse. The structure of the language: Class Parser All the primitives and combinators of the language return Parser objects It defines the main Parser.parse(tokens) method Primitive parsers tok(type, value) , a(value) , some(pred) , forward_decl() , finished Parser combinators p1 + p2 , p1 | p2 , p >> f , -p , maybe(p) , many(p) , oneplus(p) , skip(p) Abstraction Use regular Python variables p = ... # Expression of type Parser to define new rules (non-terminals) of your grammar Every time you apply one of the combinators, you get a new Parser object. In other words, the set of Parser objects is closed under the means of combination. Note We took the parsing combinators language from the book Introduction to Functional Programming and translated it from ML into Python.","title":"funcparserlib.parser \u2014 Functional parsing combinators"},{"location":"api/parser/#funcparserlib.parser.Parser","text":"Bases: object A parser object that can parse a sequence of tokens or can be combined with other parsers using + , | , >> , many() , and other parsing combinators. Type: Parser[A, B] The generic variables in the type are: A \u2014 the type of the tokens in the sequence to parse, B \u2014 the type of the parsed value. In order to define a parser for your grammar: You start with primitive parsers by calling a(value) , some(pred) , forward_decl() , finished You use parsing combinators p1 + p2 , p1 | p2 , p >> f , many(p) , and others to combine parsers into a more complex parser You can assign complex parsers to variables to define names that correspond to the rules of your grammar Note The constructor Parser.__init__() is considered internal and may be changed in future versions. Use primitive parsers and parsing combinators to construct new parsers.","title":"Parser"},{"location":"api/parser/#funcparserlib.parser.Parser.__add__","text":"Sequential combination of parsers. It runs this parser, then the other parser. The return value of the resulting parser is a tuple of each parsed value in the sum of parsers. We merge all parsing results of p1 + p2 + ... + pN into a single tuple. It means that the parsing result may be a 2-tuple, a 3-tuple, a 4-tuple, etc. of parsed values. You avoid this by transforming the parsed pair into a new value using the >> combinator. You can also skip some parsing results in the resulting parsers by using -p or skip(p) for some parsers in your sum of parsers. It means that the parsing result might be a single value, not a tuple of parsed values. See the docs for Parser.__neg__() for more examples. Overloaded types (lots of them to provide stricter checking for the quite dynamic return type of this method): (self: Parser[A, B], _IgnoredParser[A]) -> Parser[A, B] (self: Parser[A, B], Parser[A, C]) -> _TupleParser[A, Tuple[B, C]] (self: _TupleParser[A, B], _IgnoredParser[A]) -> _TupleParser[A, B] (self: _TupleParser[A, B], Parser[A, Any]) -> Parser[A, Any] (self: _IgnoredParser[A], _IgnoredParser[A]) -> _IgnoredParser[A] (self: _IgnoredParser[A], Parser[A, C]) -> Parser[A, C] Examples: >>> expr = a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"xy\" ) ('x', 'y') >>> expr = a ( \"x\" ) + a ( \"y\" ) + a ( \"z\" ) >>> expr . parse ( \"xyz\" ) ('x', 'y', 'z') >>> expr = a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"xz\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'z', expected: 'y'","title":"__add__()"},{"location":"api/parser/#funcparserlib.parser.Parser.__init__","text":"Wrap the parser function p into a Parser object.","title":"__init__()"},{"location":"api/parser/#funcparserlib.parser.Parser.__neg__","text":"Return a parser that parses the same tokens, but its parsing result is ignored by the sequential + combinator. Type: (Parser[A, B]) -> _IgnoredParser[A] You can use it for throwing away elements of concrete syntax (e.g. \",\" , \";\" ). Examples: >>> expr = - a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"xy\" ) 'y' >>> expr = a ( \"x\" ) + - a ( \"y\" ) >>> expr . parse ( \"xy\" ) 'x' >>> expr = a ( \"x\" ) + - a ( \"y\" ) + a ( \"z\" ) >>> expr . parse ( \"xyz\" ) ('x', 'z') >>> expr = - a ( \"x\" ) + a ( \"y\" ) + - a ( \"z\" ) >>> expr . parse ( \"xyz\" ) 'y' >>> expr = - a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"yz\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'y', expected: 'x' >>> expr = a ( \"x\" ) + - a ( \"y\" ) >>> expr . parse ( \"xz\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'z', expected: 'y' Note You should not pass the resulting parser to any combinators other than + . You should have at least one non-skipped value in your p1 + p2 + ... + pN . The parsed value of -p is an internal _Ignored object, not intended for actual use.","title":"__neg__()"},{"location":"api/parser/#funcparserlib.parser.Parser.__or__","text":"Choice combination of parsers. It runs this parser and returns its result. If the parser fails, it runs the other parser. Examples: >>> expr = a ( \"x\" ) | a ( \"y\" ) >>> expr . parse ( \"x\" ) 'x' >>> expr . parse ( \"y\" ) 'y' >>> expr . parse ( \"z\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'z', expected: 'x' or 'y'","title":"__or__()"},{"location":"api/parser/#funcparserlib.parser.Parser.__rshift__","text":"Transform the parsing result by applying the specified function. Type: (Callable[[B], C]) -> Parser[A, C] You can use it for transforming the parsed value into another value before including it into the parse tree (the AST). Examples: >>> def make_canonical_name ( s ): ... return s . lower () >>> expr = ( a ( \"D\" ) | a ( \"d\" )) >> make_canonical_name >>> expr . parse ( \"D\" ) 'd' >>> expr . parse ( \"d\" ) 'd'","title":"__rshift__()"},{"location":"api/parser/#funcparserlib.parser.Parser.bind","text":"Bind the parser to a monadic function that returns a new parser. Type: (Callable[[B], Parser[A, C]]) -> Parser[A, C] Also known as >>= in Haskell. Note You can parse any context-free grammar without resorting to bind . Due to its poor performance please use it only when you really need it.","title":"bind()"},{"location":"api/parser/#funcparserlib.parser.Parser.define","text":"Define the parser created earlier as a forward declaration. Type: (Parser[A, B]) -> None Use p = forward_decl() in combination with p.define(...) to define recursive parsers. See the examples in the docs for forward_decl() .","title":"define()"},{"location":"api/parser/#funcparserlib.parser.Parser.named","text":"Specify the name of the parser for easier debugging. Type: (str) -> Parser[A, B] This name is used in the debug-level parsing log. You can also get it via the Parser.name attribute. Examples: >>> expr = ( a ( \"x\" ) + a ( \"y\" )) . named ( \"expr\" ) >>> expr . name 'expr' >>> expr = a ( \"x\" ) + a ( \"y\" ) >>> expr . name \"('x', 'y')\" Note You can enable the parsing log this way: import logging logging . basicConfig ( level = logging . DEBUG ) import funcparserlib.parser funcparserlib . parser . debug = True The way to enable the parsing log may be changed in future versions.","title":"named()"},{"location":"api/parser/#funcparserlib.parser.Parser.parse","text":"Parse the sequence of tokens and return the parsed value. Type: (Sequence[A]) -> B It takes a sequence of tokens of arbitrary type A and returns the parsed value of arbitrary type B . If the parser fails to parse the tokens, it raises NoParseError . Note Although Parser.parse() can parse sequences of any objects (including str which is a sequence of str chars), the recommended way is parsing sequences of Token objects. You should use a regexp-based tokenizer make_tokenizer() defined in funcparserlib.lexer to convert your text into a sequence of Token objects before parsing it. You will get more readable parsing error messages (as Token objects contain their position in the source file) and good separation of the lexical and syntactic levels of the grammar.","title":"parse()"},{"location":"api/parser/#funcparserlib.parser.Parser.run","text":"Run the parser against the tokens with the specified parsing state. Type: (Sequence[A], State) -> Tuple[B, State] The parsing state includes the current position in the sequence being parsed, and the position of the rightmost token that has been consumed while parsing for better error messages. If the parser fails to parse the tokens, it raises NoParseError . Warning This is method is internal and may be changed in future versions. Use Parser.parse(tokens) instead and let the parser object take care of updating the parsing state.","title":"run()"},{"location":"api/parser/#funcparserlib.parser.State","text":"Bases: object Parsing state that is maintained basically for error reporting. It consists of the current position pos in the sequence being parsed, and the position max of the rightmost token that has been consumed while parsing.","title":"State"},{"location":"api/parser/#funcparserlib.parser.a","text":"Return a parser that parses a token if it's equal to value . Type: (A) -> Parser[A, A] Examples: >>> expr = a ( \"x\" ) >>> expr . parse ( \"x\" ) 'x' >>> expr . parse ( \"y\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'y', expected: 'x' Note Although Parser.parse() can parse sequences of any objects (including str which is a sequence of str chars), the recommended way is parsing sequences of Token objects. You should use a regexp-based tokenizer make_tokenizer() defined in funcparserlib.lexer to convert your text into a sequence of Token objects before parsing it. You will get more readable parsing error messages (as Token objects contain their position in the source file) and good separation of the lexical and syntactic levels of the grammar.","title":"a()"},{"location":"api/parser/#funcparserlib.parser.finished","text":"A parser that throws an exception if there are any unparsed tokens left in the sequence.","title":"finished()"},{"location":"api/parser/#funcparserlib.parser.forward_decl","text":"Return an undefined parser that can be used as a forward declaration. Type: Parser[Any, Any] Use p = forward_decl() in combination with p.define(...) to define recursive parsers. Examples: >>> expr = forward_decl () >>> expr . define ( a ( \"x\" ) + maybe ( expr ) + a ( \"y\" )) >>> expr . parse ( \"xxyy\" ) # noqa ('x', ('x', None, 'y'), 'y') >>> expr . parse ( \"xxy\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected end of file, expected: 'y' Note If you care about static types, you should add a type hint for your forward declaration, so that your type checker can check types in p.define(...) later: p : Parser [ str , int ] = forward_decl () p . define ( a ( \"x\" )) # Type checker error p . define ( a ( \"1\" ) >> int ) # OK","title":"forward_decl()"},{"location":"api/parser/#funcparserlib.parser.many","text":"Return a parser that applies the parser p as many times as it succeeds at parsing the tokens. Return a parser that infinitely applies the parser p to the input sequence of tokens as long as it successfully parses them. The parsed value is a list of the sequentially parsed values. Examples: >>> expr = many ( a ( \"x\" )) >>> expr . parse ( \"x\" ) ['x'] >>> expr . parse ( \"xx\" ) ['x', 'x'] >>> expr . parse ( \"xxxy\" ) # noqa ['x', 'x', 'x'] >>> expr . parse ( \"y\" ) []","title":"many()"},{"location":"api/parser/#funcparserlib.parser.maybe","text":"Return a parser that returns None if the parser p fails. Examples: >>> expr = maybe ( a ( \"x\" )) >>> expr . parse ( \"x\" ) 'x' >>> expr . parse ( \"y\" ) is None True","title":"maybe()"},{"location":"api/parser/#funcparserlib.parser.oneplus","text":"Return a parser that applies the parser p one or more times. A similar parser combinator many(p) means apply p zero or more times, whereas oneplus(p) means apply p one or more times. Examples: >>> expr = oneplus ( a ( \"x\" )) >>> expr . parse ( \"x\" ) ['x'] >>> expr . parse ( \"xx\" ) ['x', 'x'] >>> expr . parse ( \"y\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'y', expected: 'x'","title":"oneplus()"},{"location":"api/parser/#funcparserlib.parser.pure","text":"Wrap any object into a parser. Type: (A) -> Parser[A, A] A pure parser doesn't touch the tokens sequence, it just returns its pure x value. Also known as return in Haskell.","title":"pure()"},{"location":"api/parser/#funcparserlib.parser.skip","text":"An alias for -p . See also the docs for Parser.__neg__() .","title":"skip()"},{"location":"api/parser/#funcparserlib.parser.some","text":"Return a parser that parses a token if it satisfies the predicate pred . Type: (Callable[[A], bool]) -> Parser[A, A] Examples: >>> expr = some ( lambda s : s . isalpha ()) . named ( 'alpha' ) >>> expr . parse ( \"x\" ) 'x' >>> expr . parse ( \"y\" ) 'y' >>> expr . parse ( \"1\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: '1', expected: alpha Warning The some() combinator is quite slow and may be changed or removed in future versions. If you need a parser for a token by its type (e.g. any identifier) and maybe its value, use tok(type[, value]) instead. You should use make_tokenizer() from funcparserlib.lexer to tokenize your text first.","title":"some()"},{"location":"api/parser/#funcparserlib.parser.tok","text":"Return a parser that parses a Token and returns the string value of the token. Type: (str, Optional[str]) -> Parser[Token, str] You can match any token of the specified type or you can match a specific token by its type and value . Examples: >>> expr = tok ( \"expr\" ) >>> expr . parse ([ Token ( \"expr\" , \"foo\" )]) 'foo' >>> expr . parse ([ Token ( \"expr\" , \"bar\" )]) 'bar' >>> expr . parse ([ Token ( \"op\" , \"=\" )]) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: '=', expected: expr >>> expr = tok ( \"op\" , \"=\" ) >>> expr . parse ([ Token ( \"op\" , \"=\" )]) '=' >>> expr . parse ([ Token ( \"op\" , \"+\" )]) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: '+', expected: '=' Note In order to convert your text to parse into a sequence of Token objects, use a regexp-based tokenizer make_tokenizer() defined in funcparserlib.lexer . You will get more readable parsing error messages (as Token objects contain their position in the source file) and good separation of the lexical and syntactic levels of the grammar.","title":"tok()"},{"location":"api/parser/#funcparserlib.parser.Parser","text":"Bases: object A parser object that can parse a sequence of tokens or can be combined with other parsers using + , | , >> , many() , and other parsing combinators. Type: Parser[A, B] The generic variables in the type are: A \u2014 the type of the tokens in the sequence to parse, B \u2014 the type of the parsed value. In order to define a parser for your grammar: You start with primitive parsers by calling a(value) , some(pred) , forward_decl() , finished You use parsing combinators p1 + p2 , p1 | p2 , p >> f , many(p) , and others to combine parsers into a more complex parser You can assign complex parsers to variables to define names that correspond to the rules of your grammar Note The constructor Parser.__init__() is considered internal and may be changed in future versions. Use primitive parsers and parsing combinators to construct new parsers.","title":"Parser"},{"location":"api/parser/#funcparserlib.parser.Parser.__add__","text":"Sequential combination of parsers. It runs this parser, then the other parser. The return value of the resulting parser is a tuple of each parsed value in the sum of parsers. We merge all parsing results of p1 + p2 + ... + pN into a single tuple. It means that the parsing result may be a 2-tuple, a 3-tuple, a 4-tuple, etc. of parsed values. You avoid this by transforming the parsed pair into a new value using the >> combinator. You can also skip some parsing results in the resulting parsers by using -p or skip(p) for some parsers in your sum of parsers. It means that the parsing result might be a single value, not a tuple of parsed values. See the docs for Parser.__neg__() for more examples. Overloaded types (lots of them to provide stricter checking for the quite dynamic return type of this method): (self: Parser[A, B], _IgnoredParser[A]) -> Parser[A, B] (self: Parser[A, B], Parser[A, C]) -> _TupleParser[A, Tuple[B, C]] (self: _TupleParser[A, B], _IgnoredParser[A]) -> _TupleParser[A, B] (self: _TupleParser[A, B], Parser[A, Any]) -> Parser[A, Any] (self: _IgnoredParser[A], _IgnoredParser[A]) -> _IgnoredParser[A] (self: _IgnoredParser[A], Parser[A, C]) -> Parser[A, C] Examples: >>> expr = a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"xy\" ) ('x', 'y') >>> expr = a ( \"x\" ) + a ( \"y\" ) + a ( \"z\" ) >>> expr . parse ( \"xyz\" ) ('x', 'y', 'z') >>> expr = a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"xz\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'z', expected: 'y'","title":"__add__()"},{"location":"api/parser/#funcparserlib.parser.Parser.__init__","text":"Wrap the parser function p into a Parser object.","title":"__init__()"},{"location":"api/parser/#funcparserlib.parser.Parser.__neg__","text":"Return a parser that parses the same tokens, but its parsing result is ignored by the sequential + combinator. Type: (Parser[A, B]) -> _IgnoredParser[A] You can use it for throwing away elements of concrete syntax (e.g. \",\" , \";\" ). Examples: >>> expr = - a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"xy\" ) 'y' >>> expr = a ( \"x\" ) + - a ( \"y\" ) >>> expr . parse ( \"xy\" ) 'x' >>> expr = a ( \"x\" ) + - a ( \"y\" ) + a ( \"z\" ) >>> expr . parse ( \"xyz\" ) ('x', 'z') >>> expr = - a ( \"x\" ) + a ( \"y\" ) + - a ( \"z\" ) >>> expr . parse ( \"xyz\" ) 'y' >>> expr = - a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"yz\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'y', expected: 'x' >>> expr = a ( \"x\" ) + - a ( \"y\" ) >>> expr . parse ( \"xz\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'z', expected: 'y' Note You should not pass the resulting parser to any combinators other than + . You should have at least one non-skipped value in your p1 + p2 + ... + pN . The parsed value of -p is an internal _Ignored object, not intended for actual use.","title":"__neg__()"},{"location":"api/parser/#funcparserlib.parser.Parser.__or__","text":"Choice combination of parsers. It runs this parser and returns its result. If the parser fails, it runs the other parser. Examples: >>> expr = a ( \"x\" ) | a ( \"y\" ) >>> expr . parse ( \"x\" ) 'x' >>> expr . parse ( \"y\" ) 'y' >>> expr . parse ( \"z\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'z', expected: 'x' or 'y'","title":"__or__()"},{"location":"api/parser/#funcparserlib.parser.Parser.__rshift__","text":"Transform the parsing result by applying the specified function. Type: (Callable[[B], C]) -> Parser[A, C] You can use it for transforming the parsed value into another value before including it into the parse tree (the AST). Examples: >>> def make_canonical_name ( s ): ... return s . lower () >>> expr = ( a ( \"D\" ) | a ( \"d\" )) >> make_canonical_name >>> expr . parse ( \"D\" ) 'd' >>> expr . parse ( \"d\" ) 'd'","title":"__rshift__()"},{"location":"api/parser/#funcparserlib.parser.Parser.bind","text":"Bind the parser to a monadic function that returns a new parser. Type: (Callable[[B], Parser[A, C]]) -> Parser[A, C] Also known as >>= in Haskell. Note You can parse any context-free grammar without resorting to bind . Due to its poor performance please use it only when you really need it.","title":"bind()"},{"location":"api/parser/#funcparserlib.parser.Parser.define","text":"Define the parser created earlier as a forward declaration. Type: (Parser[A, B]) -> None Use p = forward_decl() in combination with p.define(...) to define recursive parsers. See the examples in the docs for forward_decl() .","title":"define()"},{"location":"api/parser/#funcparserlib.parser.Parser.named","text":"Specify the name of the parser for easier debugging. Type: (str) -> Parser[A, B] This name is used in the debug-level parsing log. You can also get it via the Parser.name attribute. Examples: >>> expr = ( a ( \"x\" ) + a ( \"y\" )) . named ( \"expr\" ) >>> expr . name 'expr' >>> expr = a ( \"x\" ) + a ( \"y\" ) >>> expr . name \"('x', 'y')\" Note You can enable the parsing log this way: import logging logging . basicConfig ( level = logging . DEBUG ) import funcparserlib.parser funcparserlib . parser . debug = True The way to enable the parsing log may be changed in future versions.","title":"named()"},{"location":"api/parser/#funcparserlib.parser.Parser.parse","text":"Parse the sequence of tokens and return the parsed value. Type: (Sequence[A]) -> B It takes a sequence of tokens of arbitrary type A and returns the parsed value of arbitrary type B . If the parser fails to parse the tokens, it raises NoParseError . Note Although Parser.parse() can parse sequences of any objects (including str which is a sequence of str chars), the recommended way is parsing sequences of Token objects. You should use a regexp-based tokenizer make_tokenizer() defined in funcparserlib.lexer to convert your text into a sequence of Token objects before parsing it. You will get more readable parsing error messages (as Token objects contain their position in the source file) and good separation of the lexical and syntactic levels of the grammar.","title":"parse()"},{"location":"api/parser/#funcparserlib.parser.Parser.run","text":"Run the parser against the tokens with the specified parsing state. Type: (Sequence[A], State) -> Tuple[B, State] The parsing state includes the current position in the sequence being parsed, and the position of the rightmost token that has been consumed while parsing for better error messages. If the parser fails to parse the tokens, it raises NoParseError . Warning This is method is internal and may be changed in future versions. Use Parser.parse(tokens) instead and let the parser object take care of updating the parsing state.","title":"run()"},{"location":"api/parser/#funcparserlib.parser.Parser.parse","text":"Parse the sequence of tokens and return the parsed value. Type: (Sequence[A]) -> B It takes a sequence of tokens of arbitrary type A and returns the parsed value of arbitrary type B . If the parser fails to parse the tokens, it raises NoParseError . Note Although Parser.parse() can parse sequences of any objects (including str which is a sequence of str chars), the recommended way is parsing sequences of Token objects. You should use a regexp-based tokenizer make_tokenizer() defined in funcparserlib.lexer to convert your text into a sequence of Token objects before parsing it. You will get more readable parsing error messages (as Token objects contain their position in the source file) and good separation of the lexical and syntactic levels of the grammar.","title":"parse()"},{"location":"api/parser/#funcparserlib.parser.Parser.define","text":"Define the parser created earlier as a forward declaration. Type: (Parser[A, B]) -> None Use p = forward_decl() in combination with p.define(...) to define recursive parsers. See the examples in the docs for forward_decl() .","title":"define()"},{"location":"api/parser/#funcparserlib.parser.Parser.named","text":"Specify the name of the parser for easier debugging. Type: (str) -> Parser[A, B] This name is used in the debug-level parsing log. You can also get it via the Parser.name attribute. Examples: >>> expr = ( a ( \"x\" ) + a ( \"y\" )) . named ( \"expr\" ) >>> expr . name 'expr' >>> expr = a ( \"x\" ) + a ( \"y\" ) >>> expr . name \"('x', 'y')\" Note You can enable the parsing log this way: import logging logging . basicConfig ( level = logging . DEBUG ) import funcparserlib.parser funcparserlib . parser . debug = True The way to enable the parsing log may be changed in future versions.","title":"named()"},{"location":"api/parser/#primitive-parsers","text":"","title":"Primitive Parsers"},{"location":"api/parser/#funcparserlib.parser.tok","text":"Return a parser that parses a Token and returns the string value of the token. Type: (str, Optional[str]) -> Parser[Token, str] You can match any token of the specified type or you can match a specific token by its type and value . Examples: >>> expr = tok ( \"expr\" ) >>> expr . parse ([ Token ( \"expr\" , \"foo\" )]) 'foo' >>> expr . parse ([ Token ( \"expr\" , \"bar\" )]) 'bar' >>> expr . parse ([ Token ( \"op\" , \"=\" )]) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: '=', expected: expr >>> expr = tok ( \"op\" , \"=\" ) >>> expr . parse ([ Token ( \"op\" , \"=\" )]) '=' >>> expr . parse ([ Token ( \"op\" , \"+\" )]) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: '+', expected: '=' Note In order to convert your text to parse into a sequence of Token objects, use a regexp-based tokenizer make_tokenizer() defined in funcparserlib.lexer . You will get more readable parsing error messages (as Token objects contain their position in the source file) and good separation of the lexical and syntactic levels of the grammar.","title":"tok()"},{"location":"api/parser/#funcparserlib.parser.a","text":"Return a parser that parses a token if it's equal to value . Type: (A) -> Parser[A, A] Examples: >>> expr = a ( \"x\" ) >>> expr . parse ( \"x\" ) 'x' >>> expr . parse ( \"y\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'y', expected: 'x' Note Although Parser.parse() can parse sequences of any objects (including str which is a sequence of str chars), the recommended way is parsing sequences of Token objects. You should use a regexp-based tokenizer make_tokenizer() defined in funcparserlib.lexer to convert your text into a sequence of Token objects before parsing it. You will get more readable parsing error messages (as Token objects contain their position in the source file) and good separation of the lexical and syntactic levels of the grammar.","title":"a()"},{"location":"api/parser/#funcparserlib.parser.some","text":"Return a parser that parses a token if it satisfies the predicate pred . Type: (Callable[[A], bool]) -> Parser[A, A] Examples: >>> expr = some ( lambda s : s . isalpha ()) . named ( 'alpha' ) >>> expr . parse ( \"x\" ) 'x' >>> expr . parse ( \"y\" ) 'y' >>> expr . parse ( \"1\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: '1', expected: alpha Warning The some() combinator is quite slow and may be changed or removed in future versions. If you need a parser for a token by its type (e.g. any identifier) and maybe its value, use tok(type[, value]) instead. You should use make_tokenizer() from funcparserlib.lexer to tokenize your text first.","title":"some()"},{"location":"api/parser/#funcparserlib.parser.forward_decl","text":"Return an undefined parser that can be used as a forward declaration. Type: Parser[Any, Any] Use p = forward_decl() in combination with p.define(...) to define recursive parsers. Examples: >>> expr = forward_decl () >>> expr . define ( a ( \"x\" ) + maybe ( expr ) + a ( \"y\" )) >>> expr . parse ( \"xxyy\" ) # noqa ('x', ('x', None, 'y'), 'y') >>> expr . parse ( \"xxy\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected end of file, expected: 'y' Note If you care about static types, you should add a type hint for your forward declaration, so that your type checker can check types in p.define(...) later: p : Parser [ str , int ] = forward_decl () p . define ( a ( \"x\" )) # Type checker error p . define ( a ( \"1\" ) >> int ) # OK","title":"forward_decl()"},{"location":"api/parser/#finished","text":"A parser that throws an exception if there are any unparsed tokens left in the sequence. Type: Parser[Any, None] Examples: >>> from funcparserlib.parser import a , finished >>> expr = a ( \"x\" ) + finished >>> expr . parse ( \"x\" ) ('x', None) >>> expr = a ( \"x\" ) + finished >>> expr . parse ( \"xy\" ) Traceback (most recent call last): ... funcparserlib.parser.NoParseError : got unexpected token: 'y', expected: end of file","title":"finished"},{"location":"api/parser/#parser-combinators","text":"","title":"Parser Combinators"},{"location":"api/parser/#funcparserlib.parser.Parser.__add__","text":"Sequential combination of parsers. It runs this parser, then the other parser. The return value of the resulting parser is a tuple of each parsed value in the sum of parsers. We merge all parsing results of p1 + p2 + ... + pN into a single tuple. It means that the parsing result may be a 2-tuple, a 3-tuple, a 4-tuple, etc. of parsed values. You avoid this by transforming the parsed pair into a new value using the >> combinator. You can also skip some parsing results in the resulting parsers by using -p or skip(p) for some parsers in your sum of parsers. It means that the parsing result might be a single value, not a tuple of parsed values. See the docs for Parser.__neg__() for more examples. Overloaded types (lots of them to provide stricter checking for the quite dynamic return type of this method): (self: Parser[A, B], _IgnoredParser[A]) -> Parser[A, B] (self: Parser[A, B], Parser[A, C]) -> _TupleParser[A, Tuple[B, C]] (self: _TupleParser[A, B], _IgnoredParser[A]) -> _TupleParser[A, B] (self: _TupleParser[A, B], Parser[A, Any]) -> Parser[A, Any] (self: _IgnoredParser[A], _IgnoredParser[A]) -> _IgnoredParser[A] (self: _IgnoredParser[A], Parser[A, C]) -> Parser[A, C] Examples: >>> expr = a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"xy\" ) ('x', 'y') >>> expr = a ( \"x\" ) + a ( \"y\" ) + a ( \"z\" ) >>> expr . parse ( \"xyz\" ) ('x', 'y', 'z') >>> expr = a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"xz\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'z', expected: 'y'","title":"__add__()"},{"location":"api/parser/#funcparserlib.parser.Parser.__neg__","text":"Return a parser that parses the same tokens, but its parsing result is ignored by the sequential + combinator. Type: (Parser[A, B]) -> _IgnoredParser[A] You can use it for throwing away elements of concrete syntax (e.g. \",\" , \";\" ). Examples: >>> expr = - a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"xy\" ) 'y' >>> expr = a ( \"x\" ) + - a ( \"y\" ) >>> expr . parse ( \"xy\" ) 'x' >>> expr = a ( \"x\" ) + - a ( \"y\" ) + a ( \"z\" ) >>> expr . parse ( \"xyz\" ) ('x', 'z') >>> expr = - a ( \"x\" ) + a ( \"y\" ) + - a ( \"z\" ) >>> expr . parse ( \"xyz\" ) 'y' >>> expr = - a ( \"x\" ) + a ( \"y\" ) >>> expr . parse ( \"yz\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'y', expected: 'x' >>> expr = a ( \"x\" ) + - a ( \"y\" ) >>> expr . parse ( \"xz\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'z', expected: 'y' Note You should not pass the resulting parser to any combinators other than + . You should have at least one non-skipped value in your p1 + p2 + ... + pN . The parsed value of -p is an internal _Ignored object, not intended for actual use.","title":"__neg__()"},{"location":"api/parser/#funcparserlib.parser.Parser.__or__","text":"Choice combination of parsers. It runs this parser and returns its result. If the parser fails, it runs the other parser. Examples: >>> expr = a ( \"x\" ) | a ( \"y\" ) >>> expr . parse ( \"x\" ) 'x' >>> expr . parse ( \"y\" ) 'y' >>> expr . parse ( \"z\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'z', expected: 'x' or 'y'","title":"__or__()"},{"location":"api/parser/#funcparserlib.parser.Parser.__rshift__","text":"Transform the parsing result by applying the specified function. Type: (Callable[[B], C]) -> Parser[A, C] You can use it for transforming the parsed value into another value before including it into the parse tree (the AST). Examples: >>> def make_canonical_name ( s ): ... return s . lower () >>> expr = ( a ( \"D\" ) | a ( \"d\" )) >> make_canonical_name >>> expr . parse ( \"D\" ) 'd' >>> expr . parse ( \"d\" ) 'd'","title":"__rshift__()"},{"location":"api/parser/#funcparserlib.parser.maybe","text":"Return a parser that returns None if the parser p fails. Examples: >>> expr = maybe ( a ( \"x\" )) >>> expr . parse ( \"x\" ) 'x' >>> expr . parse ( \"y\" ) is None True","title":"maybe()"},{"location":"api/parser/#funcparserlib.parser.many","text":"Return a parser that applies the parser p as many times as it succeeds at parsing the tokens. Return a parser that infinitely applies the parser p to the input sequence of tokens as long as it successfully parses them. The parsed value is a list of the sequentially parsed values. Examples: >>> expr = many ( a ( \"x\" )) >>> expr . parse ( \"x\" ) ['x'] >>> expr . parse ( \"xx\" ) ['x', 'x'] >>> expr . parse ( \"xxxy\" ) # noqa ['x', 'x', 'x'] >>> expr . parse ( \"y\" ) []","title":"many()"},{"location":"api/parser/#funcparserlib.parser.oneplus","text":"Return a parser that applies the parser p one or more times. A similar parser combinator many(p) means apply p zero or more times, whereas oneplus(p) means apply p one or more times. Examples: >>> expr = oneplus ( a ( \"x\" )) >>> expr . parse ( \"x\" ) ['x'] >>> expr . parse ( \"xx\" ) ['x', 'x'] >>> expr . parse ( \"y\" ) Traceback (most recent call last): ... parser.NoParseError : got unexpected token: 'y', expected: 'x'","title":"oneplus()"},{"location":"api/parser/#funcparserlib.parser.skip","text":"An alias for -p . See also the docs for Parser.__neg__() .","title":"skip()"},{"location":"api/parser/#extra-parser-monad","text":"As a functional programmer, you might be pleased to know, that parsers in funcparserlib form a monad with Parser.bind() as >>= and pure() as return . We could have expressed other parsing combinators in terms of bind() , but would be inefficient in Python: # noinspection PyUnresolvedReferences class Parser : def __add__ ( self , other ): return self . bind ( lambda x : other . bind ( lambda y : pure (( x , y )))) def __rshift__ ( self , other ): return self . bind ( lambda x : pure ( x ))","title":"Extra: Parser Monad"},{"location":"api/parser/#funcparserlib.parser.Parser.bind","text":"Bind the parser to a monadic function that returns a new parser. Type: (Callable[[B], Parser[A, C]]) -> Parser[A, C] Also known as >>= in Haskell. Note You can parse any context-free grammar without resorting to bind . Due to its poor performance please use it only when you really need it.","title":"bind()"},{"location":"api/parser/#funcparserlib.parser.pure","text":"Wrap any object into a parser. Type: (A) -> Parser[A, A] A pure parser doesn't touch the tokens sequence, it just returns its pure x value. Also known as return in Haskell.","title":"pure()"},{"location":"api/util/","text":"funcparserlib.util \u2014 Various utilities funcparserlib . util . pretty_tree ( x , kids , show ) Return a pseudo-graphic tree representation of the object x similar to the tree command in Unix. Type: (T, Callable[[T], List[T]], Callable[[T], str]) -> str It applies the parameter show (which is a function of type (T) -> str ) to get a textual representation of the objects to show. It applies the parameter kids (which is a function of type (T) -> List[T] ) to list the children of the object to show. Examples: >>> print ( pretty_tree ( ... [ \"foo\" , [ \"bar\" , \"baz\" ], \"quux\" ], ... lambda obj : obj if isinstance ( obj , list ) else [], ... lambda obj : \"[]\" if isinstance ( obj , list ) else str ( obj ), ... )) [] |-- foo |-- [] | |-- bar | `-- baz `-- quux","title":"Utilities"},{"location":"api/util/#funcparserlibutil-various-utilities","text":"","title":"funcparserlib.util \u2014 Various utilities"},{"location":"api/util/#funcparserlib.util.pretty_tree","text":"Return a pseudo-graphic tree representation of the object x similar to the tree command in Unix. Type: (T, Callable[[T], List[T]], Callable[[T], str]) -> str It applies the parameter show (which is a function of type (T) -> str ) to get a textual representation of the objects to show. It applies the parameter kids (which is a function of type (T) -> List[T] ) to list the children of the object to show. Examples: >>> print ( pretty_tree ( ... [ \"foo\" , [ \"bar\" , \"baz\" ], \"quux\" ], ... lambda obj : obj if isinstance ( obj , list ) else [], ... lambda obj : \"[]\" if isinstance ( obj , list ) else str ( obj ), ... )) [] |-- foo |-- [] | |-- bar | `-- baz `-- quux","title":"pretty_tree()"}]}